snippet FLOW
//{{{ ************[         Flow         ]************
// 1. (a) Complexity: O (E * V ^ 2)
//    (b) Graph with unit capacity: O (min (E ^ 1.5, E * V ^ .67))
// 2. Edges MUST be directed (for most cases, actually)
// 3. Change INF according to FLOW_TYPE
// 4. nV = number of nodes in flow network 

typedef int FLOW_TYPE;
FLOW_TYPE f [MAX_E], c [MAX_E];

int nV, s, t, gap [MAX_N], h [MAX_N], last [MAX_N];
int nE, to [MAX_E], from [MAX_E];

inline void addEdge (int u, int v, FLOW_TYPE cu, FLOW_TYPE cv = 0) { 
    to [nE] = v, from [nE] = last [u], f [nE] = 0, c [nE] = cu, last [u] = nE++;
    to [nE] = u, from [nE] = last [v], f [nE] = 0, c [nE] = cv, last [v] = nE++;
}

FLOW_TYPE isap (int u, FLOW_TYPE F) {
    if (u == t) return F;

    for (int e = last [u]; ~e; e = from [e]) {
        int v = to [e];
        if (c [e] - f [e] > 0 && h [v] + 1 == h [u]) {
            FLOW_TYPE flow = isap (v, min (F, c [e] - f [e]));
            f [e]     += flow;
            f [e ^ 1] -= flow;
            if (flow > 0) return flow;
        }
    }

    if (--gap [h [u]] == 0) h [s] = nV;
    ++gap [++h [u]];

    return 0;
}

void init (int _nV) {
    nV = _nV, nE = 0, s = n - 2, t = n - 1;
    CLR (h), CLR (gap), RST (last);
}

FLOW_TYPE flow () {
    FLOW_TYPE ret = 0; gap [0] = nV;
    while (h [s] < nV) ret += isap (s, INF);
    return ret;
}
//}}}
endsnippet
